;
; SPDX-License-Identifier: GPL-3.0-or-later
;
; Author: John David Sprunger
; Date: 4/20/2021
;

.program ir_nec

    ; We're running at 4*38222Hz = 152888Hz
    ; Each cycle ~= 6us
    ; We're using a 25% carrier duty cycle
    .wrap_target
    ; Block for data to be available on the TxFifo
    ; TODO: auto pull instead?
    pull
    out y, 32
    pull
    out x, 32
header_high:
    set pins, 1
    set pins, 0 [1]
    jmp y--, header_high
header_low:
    jmp x--, header_low [3]

    ; Need a delay between pins high of:
    ;   688 cycles ~= 4500us*152888Hz
    ;   Breakdown:
    ;     3 from end of header_high
    ;     680 from header_low
    ;     5 after header_low
    ; We set this delay as a fifo pushed value of 679
    ; in order to run the 4 cycle loop 680 times

    ; Start sending data, 32 bits per message
    pull
    set x, 31 [2]
data_loop:
    ; 86 cycles ~= 562.5us*152888hz
    ; Setting to 22 loops here because the last loop is more
    ; like 1/4 of a loop, which is close enough
    set y, 21
pulse_loop:
    set pins, 1
    set pins, 0 [1]
    jmp y--, pulse_loop

    ; For a 1, need:
    ;   86 cycles  ~= 562.5us*152888Hzz between pins set high
    ;   Breakdown:
    ;     14 before delay_loop
    ;     70 from delay_loop
    ;     2  after delay_loop
    ; For a 0 need:
    ;   258 cycles ~= 1687.5us*152888Hz between pins set high
    ;   Breakdown:
    ;     6   before delay_loop
    ;     250 from delay_loop
    ;     2   after delay_loop

    out y, 1
    jmp !y, zero_cond
    set y, 6 [7]
    jmp delay_loop
zero_cond:
    set y, 24
delay_loop: ; 10 cycles/loop
    jmp y--, delay_loop [9]
    jmp x--, data_loop

    ; Ending pulse
    set y, 21
end_loop: ; 4 cycles/loop
    set pins, 1
    set pins, 0 [1]
    jmp y--, end_loop
.wrap

% c-sdk {
static inline void ir_nec_program_init(PIO pio, uint sm, uint offset, uint pin, float div)
{
    pio_sm_config c = ir_nec_program_get_default_config(offset);

    // Map the state machine's SET pin group to one pin, namely the `pin`
    // parameter to this function.
    sm_config_set_set_pins(&c, pin, 1);
    // Set the clock divider
    sm_config_set_clkdiv(&c, div);
    // Set the out shift register direction
    sm_config_set_out_shift(&c, false, false, 32);
    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin);
    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}
